装饰模式（Decorator），动态地给一个对象添加一些额外的职责，
就增加功能来说，装饰模式比生成子类更加灵活。

装饰模式利用SetComponent来对对象进行包装，
这样每个装饰对象的实现就和如何使用这个对象分离开了，
每个装饰对象只关心自己的功能，不需要关心如何被添加到
对象链当中

如果只有一个ConcreteComponent类而没有抽象的ComcreteDecorator类
那么就没必要建一个单独的Decrator类，而可以把Decorator和ConcreteDecorator
的责任合并成一个类

在这里就没有必要有Component类，
直接让服饰类Decorator继承人类ConcreteComponent就可。









装饰模式总结

定义： 装饰模式是为已有功能动态的添加更多功能的一种方式

什么时候用：当系统需要新功能时，是向旧的类添加新的代码，这些新加的代码
通常装饰了原有类的核心职责或主要行为 。

比如用西装来装饰小菜这个人
但这种做法的问题在于，他们在主类中加入新的字段，新的方法，新的逻辑，
从而增加了主类的复杂度。
而这些新加的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。
就我的理解而言，就像人会吃饭，如果说要吃米饭，没必要在主类加，否则就成为 人会吃米饭。
应该让 米饭 这个具体类继承 饭 类
而装饰模式却提供了一个非常好的解决方案，它把每一要装饰的功能放在单独的类中，
并让这个类包装它所需要装饰的对象。
因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要，
有选择，有顺序地包装对象。

装饰模式的优点：把类中的装饰功能从类中搬移取出，这样就可以简化原有的类
有效地把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑

